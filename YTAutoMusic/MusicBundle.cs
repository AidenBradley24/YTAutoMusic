using System.Diagnostics;
using System.Globalization;

namespace YTAutoMusic
{
    internal class MusicBundle
    {
        public string Title { get; private set; }
        public FileInfo File { get; private set; }
        public string ID { get; private set; }

        private static readonly char[] SEPERATORS = { '-', '\u2012', '\u2013', '\u2014', '\u2015', '|', '·', '\uFF02', '\u0022', '\u201C', '\u201D', '\u201E', '\u201F' };

        private static readonly char[] QUOTES = { '\u0022', '\u00AB', '\u00BB', '\u201C', '\u201D', '\u201E', '\uFF02' };

        private static readonly char[] CLEAN_UP_TRIM = { ' ', '\n', '\t', '\r', '.', ':', '\uFF1A', '-', '\u2012', '\u2013', '\u2014', '\u2015', '|', '·', '\uFF02', '\u0022', '\u201C', '\u201D', '\u201E', '\u201F' };

        public MusicBundle(FileInfo file, string id, string title)
        {
            File = file;
            ID = id;
            Title = title;
        }

        public void Auto(TagLib.File tagFile, string description, PlaylistBundle playlist)
        {
            string title = Title;
            string titlePlusDescription = title + "\n" + description;

            bool finished = false;

            if (description.Contains("Provided to YouTube by"))
            {
                /*
                 * Provided to YouTube by INSERTCOMPANYHERE
                 * 
                 * Title · Artist
                 * 
                 * Album
                 * 
                 * ℗
                 * 
                 * Released on: YYYY-MM-DD
                 * 
                 * ...
                 * 
                 * Auto-generated by YouTube.
                 */

                try
                {
                    string[] lines = LineifyDescription(description);

                    Debug.Assert(lines[0].Contains("Provided to YouTube by"));

                    tagFile.Tag.Title = title;

                    string[] performers = lines[1].Split('·')[1..];
                    for (int i = 0; i < performers.Length; i++)
                    {
                        performers[i] = performers[i].Trim();
                    }

                    tagFile.Tag.Performers = performers;
                    tagFile.Tag.Album = lines[2].Trim();

                    tagFile.Tag.Copyright = lines[3].Trim();

                    tagFile.Tag.Year = (uint)DateTime.ParseExact(lines[4].Trim()[13..], "yyyy-MM-dd", CultureInfo.InvariantCulture).Year;

                    finished = true;
                    Console.WriteLine("Used information provided by YouTube to fill metadata.");
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Tried to use 'provided by' config. Failed.");
                    Console.WriteLine(ex);
                }
            }

            if (!finished && IsStandaloneWord("From", title, out string usedWord))
            {
                try
                {
                    if(!title.Contains($"({usedWord}", StringComparison.InvariantCultureIgnoreCase))
                    {
                        throw new FormatException("Not real from config");
                    }

                    string[] bits = title.Split("(", StringSplitOptions.TrimEntries);

                    string t = bits[0].Trim();
                    string a = bits[1][usedWord.Length..^1];

                    foreach(char q in QUOTES)
                    {
                        a = a.Replace(q.ToString(), "");
                    }

                    a = a.Trim();

                    tagFile.Tag.Title = t;
                    tagFile.Tag.Album = a;

                    finished = true;
                    Console.WriteLine("Parsed YT title to fill metadata. (from config)");
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Tried to use 'from' config. Failed.");
                    Console.WriteLine(ex);
                }
            }

            if (!finished && (IsStandaloneWord("OST", title, out usedWord) || IsStandaloneWord("O.S.T.", title, out usedWord) || IsStandaloneWord("Soundtrack", title, out usedWord)))
            {
                try
                {
                    var bits = title.Split(SEPERATORS, StringSplitOptions.RemoveEmptyEntries);

                    int i;
                    for (i = 0; i < bits.Length; i++)
                    {
                        if (IsStandaloneWord(usedWord, bits[i], out _))
                        {
                            break;
                        }
                    }

                    int soundtrackIndex = i;

                    if (i < bits.Length)
                    {
                        string album = bits[i].Trim().Trim(CLEAN_UP_TRIM);
                        int blacklist = -1;

                        if (album == usedWord)
                        {
                            i--;
                            if (i < 0)
                            {
                                throw new IndexOutOfRangeException("Can't find soundtrack name");
                            }

                            blacklist = i;

                            album = bits[i].Trim();
                            if(album.Length == 0)
                            {
                                throw new FormatException("Can't find soundtrack name");
                            }
                        }

                        if (usedWord == "O.S.T.")
                        {
                            album = album.Replace("O.S.T.", "OST");
                        }

                        string a = "";

                        foreach (string word in album.Split(' '))
                        {
                            string trimmedWord = word.Trim(CLEAN_UP_TRIM);

                            if (trimmedWord.Equals("OST", StringComparison.InvariantCultureIgnoreCase) ||
                                trimmedWord.Equals("Soundtrack", StringComparison.InvariantCultureIgnoreCase))
                            {
                                break;
                            }

                            a += word + " ";
                        }

                        tagFile.Tag.Album = a + "Soundtrack";

                        i++;

                        string t = null;

                        for (; i < bits.Length; i++)
                        {
                            if (i == blacklist) continue;

                            string bit = bits[i].Trim(' ', '\n', '\t', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9');
                            if (string.IsNullOrWhiteSpace(bit))
                            {
                                continue;
                            }

                            t = bit;
                        }

                        i = soundtrackIndex - 1;

                        if (t == null)
                        {
                            for (; i >= 0; i--)
                            {
                                if (i == blacklist) continue;

                                string bit = bits[i].Trim(' ', '\n', '\t', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9');
                                if (string.IsNullOrWhiteSpace(bit))
                                {
                                    continue;
                                }

                                t = bit;
                            }
                        }

                        if(t == null)
                        {
                            throw new FormatException("Title failed");
                        }

                        t = t.Trim(CLEAN_UP_TRIM);
                        
                        tagFile.Tag.Title = t;
                    }

                    tagFile.Tag.Genres = new string[]{ "Soundtrack" };
                    finished = true;
                    Console.WriteLine("Parsed YT title to fill metadata. (soundtrack config)");
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Tried to use 'soundtrack' config. Failed.");
                    Console.WriteLine(ex);
                }
            }

            if(!finished && (IsWord("Music ", description, out usedWord) || IsWord("Title ", description, out usedWord)))
            {
                try
                {
                    var lines = LineifyDescription(description).AsEnumerable();

                    var possibleLines = lines.Where(l => l.StartsWith(usedWord, StringComparison.InvariantCultureIgnoreCase));
                    if (!possibleLines.Any())
                    {
                        throw new FormatException("Not real 'music description'");
                    }

                    string titleLine = possibleLines.First();
                    titleLine = titleLine[usedWord.Length..];

                    (string t, string a) = SplitFirst(titleLine);

                    t = t.Trim(CLEAN_UP_TRIM);
                    a = a.Trim(CLEAN_UP_TRIM);

                    if (!title.Contains(t))
                    {
                        throw new FormatException("Not real 'music description'");
                    }

                    if (string.IsNullOrWhiteSpace(a))
                    {
                        tagFile.Tag.Title = t;
                        tagFile.Tag.Album = "";
                    }
                    else
                    {
                        tagFile.Tag.Title = t;
                        tagFile.Tag.Album = a;
                    }

                    finished = true;
                    Console.WriteLine("Parsed YT description to fill metadata. (music description config)");
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Tried to use 'music description' config. Failed.");
                    Console.WriteLine(ex);
                }

            }

            if (!finished)
            {
                tagFile.Tag.Title = title;
                tagFile.Tag.Album = "";
            }
        }

        private static string[] LineifyDescription(string description)
        {
            return description.Split('\n', StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
        }

        /// <summary>
        /// Check for if word is inside sentence. Insures that word is isolated with only whitespace, an edge, or symbols surounding it.
        /// </summary>
        /// <param name="word">Word to check</param>
        /// <param name="sentence">Sentence to check for word</param>
        /// <param name="usedWord">Returns given work back. (To determine which word was used out of many)</param>
        /// <returns></returns>
        public static bool IsStandaloneWord(string word, string sentence, out string usedWord)
        {
            int index = sentence.IndexOf(word, StringComparison.OrdinalIgnoreCase);
            usedWord = word;

            if (index == -1)
            {
                return false;
            }

            if (index != 0 && char.IsLetterOrDigit(sentence[index - 1]))
            {
                return false;
            }

            if (index + word.Length < sentence.Length - 1 && char.IsLetterOrDigit(sentence[index + word.Length]))
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Calls the 'contains' method on sentence with InvariantCultureIgnoreCase. In same format as IsStandaloneWord.
        /// </summary>
        /// <param name="word">Word to check</param>
        /// <param name="sentence">Sentence to check for word</param>
        /// <param name="usedWord">Returns given work back. (To determine which word was used out of many)</param>
        /// <returns></returns>
        public static bool IsWord(string word, string sentence, out string usedWord)
        {
            usedWord = word;

            if (sentence.Contains(word, StringComparison.InvariantCultureIgnoreCase))
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Split a sentence by only the first divider. If there is no split, second half will be "".
        /// </summary>
        /// <param name="sentence">Sentence to split</param>
        /// <returns>(first half, second half)</returns>
        public static (string, string) SplitFirst(string sentence)
        {
            for (int i = 0; i < sentence.Length; i++)
            {
                char c = sentence[i];
                if(SEPERATORS.Contains(c))
                {
                    string first = sentence[..i].Trim();
                    string last = sentence[(i + 1)..].Trim();

                    return (first, last);
                }
            }

            return (sentence.Trim(), "");
        }
    }
}
